// Collection of base selectors (without list IDs that might change)
// v.0.12
// Values for each row
const VALUES = [
{
    start: {date: '01/05/2022', hours: '01', minutes: '05', amPm: 'AM'},
    end: {date: '02/06/2022', hours: '02', minutes: '10', amPm: 'AM'},
    hourType: 'Travel',
    servType: 'On-Site Service'
},
{
    start: {date: '06/16/2023', hours: '11', minutes: '15', amPm: 'AM'},
    end: {date: '07/17/2023', hours: '12', minutes: '20', amPm: 'PM'},
    hourType: 'Service',
    servType: 'On-Site Service'
},
{
    start: {date: '11/22/2024', hours: '10', minutes: '50', amPm: 'PM'},
    end: {date: '11/22/2024', hours: '11', minutes: '55', amPm: 'PM'},
    hourType: 'Travel',
    servType: 'On-Site Service'
}
];

const SEL = {
    // Grid rows
    ROWS: '#svmx-listcomposite-1092-body tr.svmx-grid-row',
    // Input fields
    HOUR_TYPE: '#sfm-picklistcelleditor-1061-triggerWrap',      
    SERVICE_TYPE: '#sfm-picklistcelleditor-1062-triggerWrap',   
    START_DATE: '#svmx-date-1064-inputEl',
    END_DATE: '#svmx-date-1071-inputEl',

    // Start time dropdown triggers
    S_HOUR: '#svmx-picklist-1065-triggerWrap .svmx-form-trigger',
    S_MIN: '#svmx-picklist-1066-triggerWrap .svmx-form-trigger',
    S_AM_PM: '#svmx-picklist-1067-triggerWrap .svmx-form-trigger',

    // End time dropdown triggers
    E_HOUR: '#svmx-picklist-1072-triggerWrap .svmx-form-trigger',
    E_MIN: '#svmx-picklist-1073-triggerWrap .svmx-form-trigger',
    E_AM_PM: '#svmx-picklist-1074-triggerWrap .svmx-form-trigger',

    // Grid column identifiers
    COLUMNS: {
        "Hour Type": "svmx-grid-cell-gridcolumn-1081",
        "Service Type": "svmx-grid-cell-gridcolumn-1082",
        "Start Date Time": "svmx-grid-cell-gridcolumn-1083",
        "End Date Time": "svmx-grid-cell-gridcolumn-1084"
    }
};

/**
 * –ö–ª–∞—Å—Å –¥–ª—è —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è –ø—Ä–æ—Ü–µ—Å—Å–æ–º –ø—Ä–æ–≤–µ—Ä–∫–∏, —Å–æ–∑–¥–∞–Ω–∏—è –∏ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏—è —Å—Ç—Ä–æ–∫ —Ç–∞–±–ª–∏—Ü—ã
 */
class ProcessManager {
    constructor(tableProcessor, dateUpdater) {
        this.tableProcessor = tableProcessor;
        this.dateUpdater = dateUpdater;
    }

    async createAndFillRows() {
        try {
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∑–∞–≥–æ–ª–æ–≤–∫–æ–≤
            await this.tableProcessor.verifyHeaders();

            // –°–æ–∑–¥–∞–Ω–∏–µ —Å—Ç—Ä–æ–∫
            await this.tableProcessor.createRows();

            // –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö —Å—Ç—Ä–æ–∫ —Ç–∞–±–ª–∏—Ü—ã
            const allRows = this.dateUpdater.getRows();

            // –ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Ç—Ä–µ—Ö —Å—Ç—Ä–æ–∫
            const newRows = Array.from(allRows).slice(-this.tableProcessor.createdRowsCount);

            // –ó–∞–ø–æ–ª–Ω–µ–Ω–∏–µ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö —Ç—Ä–µ—Ö —Å—Ç—Ä–æ–∫ –¥–∞–Ω–Ω—ã–º–∏ –∏–∑ VALUES
            for (let i = 0; i < newRows.length; i++) {
                const row = newRows[i];
                const rowValues = VALUES[i]; // –ü—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ—Ç—Å—è, —á—Ç–æ VALUES —Å–æ–¥–µ—Ä–∂–∏—Ç –¥–∞–Ω–Ω—ã–µ –¥–ª—è –Ω–æ–≤—ã—Ö —Å—Ç—Ä–æ–∫

                // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –¥–∞—Ç –∏ –≤—Ä–µ–º–µ–Ω–∏
                await this.dateUpdater.setDateTime(row, SEL.COLUMNS["Start Date Time"], {
                    SLdate: SEL.START_DATE,
                    SLhour: SEL.S_HOUR,
                    SLminu: SEL.S_MIN,
                    SLamPm: SEL.S_AM_PM
                }, rowValues.start, "Start Date Time");

                await this.dateUpdater.setDateTime(row, SEL.COLUMNS["End Date Time"], {
                    SLdate: SEL.END_DATE,
                    SLhour: SEL.E_HOUR,
                    SLminu: SEL.E_MIN,
                    SLamPm: SEL.E_AM_PM
                }, rowValues.end, "End Date Time");

                // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ç–∏–ø–æ–≤
                await this.dateUpdater.setHSType(this.dateUpdater.getRowIndex(row), {
                    column: SEL.COLUMNS["Hour Type"],
                    value: rowValues.hourType,
                    fieldName: "Hour Type"
                });

                await this.dateUpdater.setHSType(this.dateUpdater.getRowIndex(row), {
                    column: SEL.COLUMNS["Service Type"],
                    value: rowValues.servType,
                    fieldName: "Service Type"
                });
            }

            console.log('‚úÖ –ü–æ—Å–ª–µ–¥–Ω–∏–µ —Ç—Ä–∏ —Å—Ç—Ä–æ–∫–∏ –∑–∞–ø–æ–ª–Ω–µ–Ω—ã —É—Å–ø–µ—à–Ω–æ.');
        } catch (error) {
            console.error('‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –∏ –∑–∞–ø–æ–ª–Ω–µ–Ω–∏–∏ —Å—Ç—Ä–æ–∫:', error.message);
        }
    }

/*
// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ 
const COLUMNS = {
    "Hour Type": "svmx-grid-cell-gridcolumn-1081",
    "Service Type": "svmx-grid-cell-gridcolumn-1082",
    "Start Date Time": "svmx-grid-cell-gridcolumn-1083",
    "End Date Time": "svmx-grid-cell-gridcolumn-1084"
};
const tableProcessor = new TableProcessor(COLUMNS);
const dateUpdater = new DateUpdater(false); // –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ false –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è –æ—Ç–ª–∞–¥–∫–∏

const processManager = new ProcessManager(tableProcessor, dateUpdater);
processManager.createAndFillRows();
*/
}


/**
 * –ö–ª–∞—Å—Å –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–∞—Ç, –≤—Ä–µ–º–µ–Ω–∏ –∏ —Ç–∏–ø–æ–≤ –≤ —Å—Ç—Ä–æ–∫–∞—Ö —Ç–∞–±–ª–∏—Ü—ã
 */
class DateUpdater {
    /**
     * @param {boolean} noDebug - Set false to enable debug logging
     */
    constructor(noDebug = true) {
        this.debug = !noDebug;
        this.wait = ms => new Promise(resolve => setTimeout(resolve, ms));
    }

    log(...args) {
        if (this.debug) {
            console.log(...args);
        }
    }

    /**
     * –ú–µ—Ç–æ–¥ –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø–æ —Å–µ–ª–µ–∫—Ç–æ—Ä—É
     * @param {string} description - –û–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
     * @param {string} selector - –°–µ–ª–µ–∫—Ç–æ—Ä –¥–ª—è –ø–æ–∏—Å–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
     */
    logElements(description, selector) {
        const elements = document.querySelectorAll(selector);
            if (elements.length === 0) {
                console.warn(`‚ùå ${description}: –ù–µ—Ç –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø–æ —Å–µ–ª–µ–∫—Ç–æ—Ä—É "${selector}"`);
            } else {
                console.log(`‚úÖ ${description}: –ù–∞–π–¥–µ–Ω–æ ${elements.length} —ç–ª–µ–º–µ–Ω—Ç(–æ–≤) –ø–æ —Å–µ–ª–µ–∫—Ç–æ—Ä—É "${selector}"`);
                elements.forEach((el, index) => {
                    console.log(`   [${index}] Tag: ${el.tagName}, ID: ${el.id || '–Ω–µ—Ç'}, Classes: ${el.className}`);
                });
            }
        }

        async findList(type, value = null) {
            this.log(`\n--- findList: Searching for: ${type}, ${value} ---`);

                const visibleLists = Array.from(document.querySelectorAll('.svmx-boundlist'))
                    .filter(list => window.getComputedStyle(list).display !== 'none');

                        this.log(`Found ${visibleLists.length} visible lists.`);

    // –û–ø—Ä–µ–¥–µ–ª—è–µ–º –æ–∂–∏–¥–∞–µ–º—ã–µ —Ä–∞–∑–º–µ—Ä—ã –¥–ª—è —Ä–∞–∑–Ω—ã—Ö —Ç–∏–ø–æ–≤ —Å–ø–∏—Å–∫–æ–≤
                            const expectedSizes = { hours: 12, minutes: 60, ampm: 2 }; 
                            let targetSize = expectedSizes[type];

    // –ï—Å–ª–∏ —ç—Ç–æ –ø–æ–∏—Å–∫ –ø–æ —Ç–∏–ø—É (hourType/servType)
                            if (value) {
                                this.log(`#HoSeT Searching for specific value: ${value}`);
                                targetSize = null;
                            }

                            let suitableList = null;
                            for (const [index, list] of visibleLists.entries()) {
                                const items = Array.from(list.querySelectorAll('.svmx-boundlist-item'))
                                .map(item => item.textContent.trim());
                                const size = items.length;
                                this.log(`List ${index + 1}:${list.id}: ${size} items`, items);

        // –î–ª—è –ø–æ–∏—Å–∫–∞ –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∑–Ω–∞—á–µ–Ω–∏—è
                                if (value && items.includes(value)) {
                                    this.log(`Found list with value "${value}"`);
                                    suitableList = list;
                                    break;
                                }

        // –î–ª—è –ø–æ–∏—Å–∫–∞ –ø–æ —Ä–∞–∑–º–µ—Ä—É —Å–ø–∏—Å–∫–∞
                                if (targetSize && size === targetSize) {
                                    this.log(`List ${list.id} matches size ${targetSize} for type "${type}"`);
                                    suitableList = list;
                                }
                            }

                            if (!suitableList) {
                                this.log(`No suitable list found for type "${type}"${value ? ` with value "${value}"` : ''}`);
                            } else {
                                this.log('Found suitable list:', suitableList.id);
                            }

                            return suitableList;
                        }

                        async setTimeField(selector, fieldType, targetValue, fieldName) {
       // –ö–ª–∏–∫ –ø–æ —ç–ª–µ–º–µ–Ω—Ç—É –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è —Å–ø–∏—Å–∫–∞
                            const trigger = document.querySelector(selector);
                               if (!trigger) {
                                console.error(`‚ùå Trigger for ${fieldType} not found`);
                                return false;
                            }
                            trigger.click();

        // –î–∏–Ω–∞–º–∏—á–µ—Å–∫–æ–µ –æ–∂–∏–¥–∞–Ω–∏–µ –ø–æ—è–≤–ª–µ–Ω–∏—è —Å–ø–∏—Å–∫–∞
                                let attempts = 10;
                                let list = null;

                                while (attempts > 0 && !list) {
                                    list = await this.findList(fieldType);
                                    if (!list) {
                await this.wait(10); // –ñ–¥–µ–º 10 –º—Å –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø–æ–ø—ã—Ç–∫–æ–π
                attempts--;
            }
        }

        this.log(`Attempts "${11 - attempts}" for ${fieldType}`);

            if (!list) {
                console.error(`‚ùå ${fieldType.toUpperCase()} list not found for "${fieldName}"`);
                return false;
            }


        // –ü–æ–∏—Å–∫ –Ω—É–∂–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞ –≤ —Å–ø–∏—Å–∫–µ –∏ –∫–ª–∏–∫ –ø–æ –Ω–µ–º—É
            const option = Array.from(list.querySelectorAll('.svmx-boundlist-item'))
                .find(el => el.textContent.trim() === targetValue);

                    if (!option) {
                        console.error(`‚ùå ${fieldType.toUpperCase()} option "${targetValue}" not found for "${fieldName}"`);
                        return false;
                    }

                    option.click();
                        this.log(`‚úÖ ${fieldType.toUpperCase()} set to "${targetValue}" for "${fieldName}"`);
                            return true;
                        }

    /**
 * –ú–µ—Ç–æ–¥ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ —Ç–∏–ø–æ–≤ (Hour Type –∏ Service Type) –≤ —Å—Ç—Ä–æ–∫–µ
 * –û—Å–Ω–æ–≤–∞–Ω –Ω–∞ —Ä–∞–±–æ—á–µ–º –∫–ª–∞—Å—Å–µ ServiceSelector
 * 
 * @param {number} rowIndex - –ò–Ω–¥–µ–∫—Å —Å—Ç—Ä–æ–∫–∏
 * @param {object} options - –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –≤—ã–±–æ—Ä–∞
 * @param {string} options.column - –ö–ª–∞—Å—Å —Å—Ç–æ–ª–±—Ü–∞
 * @param {string} options.value - –ó–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è –≤—ã–±–æ—Ä–∞
 * @param {string} options.fieldName - –ù–∞–∑–≤–∞–Ω–∏–µ –ø–æ–ª—è –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
 * @returns {boolean} - –£—Å–ø–µ—à–Ω–æ –ª–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ
 */
                        async setHSType(rowIndex, options) {
                            const { column, value, fieldName } = options;

                            try {
                                this.log(`\n=== –û–±—Ä–∞–±–æ—Ç–∫–∞ "${fieldName}" –¥–ª—è —Å—Ç—Ä–æ–∫–∏ ${rowIndex + 1} ===`);

        // –õ–æ–≥–∏—Ä—É–µ–º –≤—Å–µ —è—á–µ–π–∫–∏ –≤ —É–∫–∞–∑–∞–Ω–Ω–æ–º —Å—Ç–æ–ª–±—Ü–µ
                                this.logElements(`–≠–ª–µ–º–µ–Ω—Ç—ã —Å –∫–ª–∞—Å—Å–æ–º "${column}"`, `.${column}`);
                                const cells = document.querySelectorAll(`.${column}`);
                                const cell = cells[rowIndex];

                                if (!cell) {
                                    throw new Error(`‚ùå –Ø—á–µ–π–∫–∞ —Å –∫–ª–∞—Å—Å–æ–º "${column}" –¥–ª—è —Å—Ç—Ä–æ–∫–∏ ${rowIndex + 1} –Ω–µ –Ω–∞–π–¥–µ–Ω–∞`);
                                }

                                this.log(`üîÑ –ö–ª–∏–∫ –ø–æ —è—á–µ–π–∫–µ –≤ —Å—Ç—Ä–æ–∫–µ ${rowIndex + 1}`);
                                cell.click();
        await this.wait(100); // ‚ùóÔ∏è –ù–µ —É–≤–µ–ª–∏—á–∏–≤–∞—Ç—å –∑–∞–¥–µ—Ä–∂–∫—É

        // –ü–æ–ª—É—á–µ–Ω–∏–µ —Å–µ–ª–µ–∫—Ç–æ—Ä–∞ –∏–∑ SEL –Ω–∞ –æ—Å–Ω–æ–≤–µ fieldName
        const fieldSelectorMap = {
            "Hour Type": SEL.HOUR_TYPE,
            "Service Type": SEL.SERVICE_TYPE
        };
        const editorSelector = fieldSelectorMap[fieldName];
        if (!editorSelector) {
            throw new Error(`‚ùå –ù–µ—Ç —Å–µ–ª–µ–∫—Ç–æ—Ä–∞ –¥–ª—è –ø–æ–ª—è "${fieldName}"`);
        }
        this.log(`üîç –ü–æ–∏—Å–∫ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞: "${editorSelector}"`);

        // –õ–æ–≥–∏—Ä—É–µ–º –ø–æ–∏—Å–∫ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞ –ø–æ —Å–µ–ª–µ–∫—Ç–æ—Ä—É
        this.logElements(`–†–µ–¥–∞–∫—Ç–æ—Ä—ã —Å —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–º "${editorSelector}"`, editorSelector);
        const fieldEditor = document.querySelector(editorSelector);
        
        if (!fieldEditor) {
            throw new Error('‚ùå Field editor –Ω–µ –ø–æ—è–≤–∏–ª—Å—è');
        }

        // –õ–æ–≥–∏—Ä—É–µ–º —Ç—Ä–∏–≥–≥–µ—Ä—ã —Å–ø–∏—Å–∫–∞ –≤–Ω—É—Ç—Ä–∏ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞
        this.logElements('–¢—Ä–∏–≥–≥–µ—Ä—ã —Å–ø–∏—Å–∫–∞ –≤–Ω—É—Ç—Ä–∏ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞', `${editorSelector} .svmx-form-trigger.svmx-form-arrow-trigger`);
        const arrowTrigger = fieldEditor.querySelector('.svmx-form-trigger.svmx-form-arrow-trigger');
        if (!arrowTrigger) {
            throw new Error('‚ùå –¢—Ä–∏–≥–≥–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω –≤ —Ä–µ–¥–∞–∫—Ç–æ—Ä–µ');
        }

        this.log('üîÑ –ö–ª–∏–∫ –ø–æ —Ç—Ä–∏–≥–≥–µ—Ä—É —Å–ø–∏—Å–∫–∞');
        arrowTrigger.click();
        await this.wait(100);

        // –õ–æ–≥–∏—Ä—É–µ–º –ø–æ–∏—Å–∫ —Å–ø–∏—Å–∫–∞ –ø–æ ID
        this.logElements(`–í—Å–µ —Å–ø–∏—Å–∫–∏ —Å ID, –Ω–∞—á–∏–Ω–∞—é—â–∏–º–∏—Å—è –Ω–∞ "boundlist-"`, '[id^="boundlist-"]');
        const allBoundLists = document.querySelectorAll('[id^="boundlist-"]');
        if (allBoundLists.length === 0) {
            throw new Error('‚ùå –ù–µ—Ç –Ω–∏ –æ–¥–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞ —Å ID, –Ω–∞—á–∏–Ω–∞—é—â–∏–º—Å—è –Ω–∞ "boundlist-"');
        }

        // –ü–µ—Ä–µ–±–∏—Ä–∞–µ–º –≤—Å–µ –Ω–∞–π–¥–µ–Ω–Ω—ã–µ —Å–ø–∏—Å–∫–∏ –∏ –∏—â–µ–º –Ω—É–∂–Ω—É—é –æ–ø—Ü–∏—é
        let boundList = null;
        for (const list of allBoundLists) {
            const listItems = list.querySelectorAll('.svmx-boundlist-item');
            const availableOptions = Array.from(listItems).map(el => el.textContent.trim());
            this.log(`üîç –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–ø–∏—Å–∫–∞ ID "${list.id}" –Ω–∞ –Ω–∞–ª–∏—á–∏–µ –æ–ø—Ü–∏–∏ "${value}":`, availableOptions);
            
            if (availableOptions.includes(value)) {
                boundList = list;
                this.log(`‚úÖ –°–ø–∏—Å–æ–∫ —Å ID "${list.id}" —Å–æ–¥–µ—Ä–∂–∏—Ç –æ–ø—Ü–∏—é "${value}"`);
                break;
            }
        }

        if (!boundList) {
            throw new Error(`‚ùå –°–ø–∏—Å–æ–∫ —Å –æ–ø—Ü–∏–µ–π "${value}" –Ω–µ –Ω–∞–π–¥–µ–Ω —Å—Ä–µ–¥–∏ –≤—Å–µ—Ö —Å–ø–∏—Å–∫–æ–≤`);
        }

        // –õ–æ–≥–∏—Ä—É–µ–º —ç–ª–µ–º–µ–Ω—Ç—ã –Ω–∞–π–¥–µ–Ω–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞
        this.logElements('–≠–ª–µ–º–µ–Ω—Ç—ã –Ω–∞–π–¥–µ–Ω–Ω–æ–≥–æ —Å–ø–∏—Å–∫–∞', `#${boundList.id} .svmx-boundlist-item`);
        const listItems = boundList.querySelectorAll('.svmx-boundlist-item');

        const availableOptions = Array.from(listItems).map(el => el.textContent.trim());
        this.log('üìÑ –î–æ—Å—Ç—É–ø–Ω—ã–µ –æ–ø—Ü–∏–∏ –≤ –Ω–∞–π–¥–µ–Ω–Ω–æ–º —Å–ø–∏—Å–∫–µ:', availableOptions);

        const option = Array.from(listItems).find(el => el.textContent.trim() === value);

        if (option) {
            this.log(`‚úÖ –í—ã–±–∏—Ä–∞–µ–º –æ–ø—Ü–∏—é "${value}"`);
            option.click();
            await this.wait(100);
            return true;
        } else {
            throw new Error(`‚ùå –û–ø—Ü–∏—è "${value}" –Ω–µ –Ω–∞–π–¥–µ–Ω–∞ –≤ –Ω–∞–π–¥–µ–Ω–Ω–æ–º —Å–ø–∏—Å–∫–µ. –î–æ—Å—Ç—É–ø–Ω—ã–µ –æ–ø—Ü–∏–∏: ${availableOptions.join(', ')}`);
        }
    } catch (error) {
        console.error(`‚ùóÔ∏è –û—à–∏–±–∫–∞ –≤ —Å—Ç—Ä–æ–∫–µ ${rowIndex + 1}:`, error.message);
        return false;
    }
}


    /**
     * –ú–µ—Ç–æ–¥ –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø–æ —Å–µ–ª–µ–∫—Ç–æ—Ä—É
     * @param {string} description - –û–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
     * @param {string} selector - –°–µ–ª–µ–∫—Ç–æ—Ä –¥–ª—è –ø–æ–∏—Å–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
     */
logElements(description, selector) {
    const elements = document.querySelectorAll(selector);
        if (elements.length === 0) {
            console.warn(`‚ùå ${description}: –ù–µ—Ç –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø–æ —Å–µ–ª–µ–∫—Ç–æ—Ä—É "${selector}"`);
        } else {
            console.log(`‚úÖ ${description}: –ù–∞–π–¥–µ–Ω–æ ${elements.length} —ç–ª–µ–º–µ–Ω—Ç(–æ–≤) –ø–æ —Å–µ–ª–µ–∫—Ç–æ—Ä—É "${selector}"`);
            elements.forEach((el, index) => {
                console.log(`   [${index}] Tag: ${el.tagName}, ID: ${el.id || '–Ω–µ—Ç'}, Classes: ${el.className}`);
            });
        }
    }


    async clickOnBlank(){   //svmx-grid-cell-gridcolumn-1084 //'#actioncolumn-1080-titleEl'  //#svmx-listcomposite-1092-body
        // this.log(` *** Click on Blank ***`);
        // const cell = querySelector(`#svmx-listcomposite-1092-body`);
        // this.log(`Clicking on "${value}" cell.`);
        // cell.click();
        // await this.wait(100);
    }

    /**
     * –ú–µ—Ç–æ–¥ –¥–ª—è —É—Å—Ç–∞–Ω–æ–≤–∫–∏ –¥–∞—Ç—ã –∏ –≤—Ä–µ–º–µ–Ω–∏ –≤ —Å—Ç—Ä–æ–∫–µ
     * @param {HTMLElement} row - –°—Ç—Ä–æ–∫–∞ —Ç–∞–±–ª–∏—Ü—ã
     * @param {string} columnClass - –ö–ª–∞—Å—Å —Å—Ç–æ–ª–±—Ü–∞
     * @param {object} selectors - –°–µ–ª–µ–∫—Ç–æ—Ä—ã –¥–ª—è –ø–æ–ª–µ–π –¥–∞—Ç—ã –∏ –≤—Ä–µ–º–µ–Ω–∏
     * @param {object} dateTime - –ó–Ω–∞—á–µ–Ω–∏—è –¥–∞—Ç—ã –∏ –≤—Ä–µ–º–µ–Ω–∏
     * @param {string} fieldName - –ù–∞–∑–≤–∞–Ω–∏–µ –ø–æ–ª—è –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
     * @returns {boolean} - –£—Å–ø–µ—à–Ω–æ –ª–∏ –≤—ã–ø–æ–ª–Ω–µ–Ω–æ
     */
    async setDateTime(row, columnClass, selectors, dateTime, fieldName) {
        this.log(`--- Setting DateTime for "${fieldName}" ---`);
            this.log(`Row: ${row.className}, Column: ${columnClass}, DateTime: ${JSON.stringify(dateTime)}`);
                this.log(`Selectors: ${JSON.stringify(selectors)}`);
        const cell = row.querySelector(`.${columnClass}`);              // e.g., svmx-grid-cell-gridcolumn-1083
            if (!cell) {
                console.error(`‚ùå Cell for "${fieldName}" not found.`);
                return false;
            }

            this.log(`üîÑ Clicking on "${fieldName}" cell.`);
                cell.click();
                    await this.wait(100);

            // Set date value
                        const dateInput = document.querySelector(selectors.SLdate);
                            if (dateInput) {
                                this.log(`üìÖ Setting date to "${dateTime.date}" for "${fieldName}". Current value: "${dateInput.value}"`);
                                dateInput.value = '';
                                dateInput.dispatchEvent(new Event('input', { bubbles: true }));
                                dateInput.value = dateTime.date;
                                dateInput.dispatchEvent(new Event('input', { bubbles: true }));
                                dateInput.dispatchEvent(new Event('change', { bubbles: true }));
                                this.log(`‚úÖ Date "${dateTime.date}" set for "${fieldName}".`);
                            } else {
                                console.error(`‚ùå Input field for "${fieldName}" not found.`);
                            }
                            await this.wait(100);

        // Set time
                                await this.setTimeField(selectors.SLhour, 'hours', dateTime.hours, fieldName);
        await this.wait(150); // –ù–µ–±–æ–ª—å—à–∞—è –∑–∞–¥–µ—Ä–∂–∫–∞ –º–µ–∂–¥—É —É—Å—Ç–∞–Ω–æ–≤–∫–∞–º–∏
            await this.setTimeField(selectors.SLminu, 'minutes', dateTime.minutes, fieldName);
                await this.wait(150);
                    await this.setTimeField(selectors.SLamPm, 'ampm', dateTime.amPm, fieldName);
                        await this.wait(150);
                    }

    /**
     * –ú–µ—Ç–æ–¥ –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω–¥–µ–∫—Å–∞ —Å—Ç—Ä–æ–∫–∏ –ø–æ —ç–ª–µ–º–µ–Ω—Ç—É row
     * @param {HTMLElement} row - –≠–ª–µ–º–µ–Ω—Ç —Å—Ç—Ä–æ–∫–∏
     * @returns {number} - –ò–Ω–¥–µ–∫—Å —Å—Ç—Ä–æ–∫–∏
     */
                    getRowIndex(row) {
                        const rows = Array.from(document.querySelectorAll(SEL.ROWS));
                            return rows.indexOf(row);
                        }

    /**
     * –ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö —Å—Ç—Ä–æ–∫ —Ç–∞–±–ª–∏—Ü—ã
     * @returns {HTMLElement[]} - –ú–∞—Å—Å–∏–≤ —Å—Ç—Ä–æ–∫ —Ç–∞–±–ª–∏—Ü—ã
     */
                        getRows() {
                            const rows = Array.from(document.querySelectorAll(SEL.ROWS));
                                this.log(`Found ${rows.length} rows.`);
                                    return rows;
                                }

    /**
     * –û—Å–Ω–æ–≤–Ω–æ–π –º–µ—Ç–æ–¥ –¥–ª—è –∑–∞–ø—É—Å–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö
     */
                                async run() {
                                    const rows = this.getRows();
                                        if (!rows.length) {
                                            console.error('‚ùå No rows found. Exiting.');
                                            return;
                                        }

                                        const startDTSelectors = {
                                            SLdate: SEL.START_DATE,
                                            SLhour: SEL.S_HOUR,
                                            SLminu: SEL.S_MIN,
                                            SLamPm: SEL.S_AM_PM
                                        };

                                        const endDTSelectors = {
                                            SLdate: SEL.END_DATE,
                                            SLhour: SEL.E_HOUR,
                                            SLminu: SEL.E_MIN,
                                            SLamPm: SEL.E_AM_PM
                                        };

        // –û–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ —Å–µ–ª–µ–∫—Ç–æ—Ä–æ–≤ –¥–ª—è Hour Type –∏ Service Type
        // –¢–µ–ø–µ—Ä—å setHSType –∏—Å–ø–æ–ª—å–∑—É–µ—Ç fieldName –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Å–µ–ª–µ–∫—Ç–æ—Ä–∞ –∏–∑ SEL
        // –ü–æ—ç—Ç–æ–º—É –Ω–µ –Ω—É–∂–Ω–æ –ø–µ—Ä–µ–¥–∞–≤–∞—Ç—å editorId
                                        for (let i = 0; i < rows.length; i++) {
                                            const row = rows[i];
                                            this.log(`\nüîÑ –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Ç—Ä–æ–∫–∏ ${i + 1}/${rows.length}`);
                                            this.log(`üìÑ –î–µ—Ç–∞–ª–∏ —Å—Ç—Ä–æ–∫–∏ ${i + 1}: ${row.className}`);

                                            if (i < VALUES.length) {
                                                const rowValues = VALUES[i];
                // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –¥–∞—Ç –∏ –≤—Ä–µ–º–µ–Ω–∏
                                                await this.setDateTime(row, SEL.COLUMNS["Start Date Time"], startDTSelectors, rowValues.start, "Start Date Time");
                                                await this.setDateTime(row, SEL.COLUMNS["End Date Time"], endDTSelectors, rowValues.end, "End Date Time");
                // –£—Å—Ç–∞–Ω–æ–≤–∫–∞ —Ç–∏–ø–æ–≤
                                                await this.setHSType(i, {
                                                    column: SEL.COLUMNS["Hour Type"],
                                                    value: rowValues.hourType,
                                                    fieldName: "Hour Type"
                                                });
                                                await this.setHSType(i, {
                                                    column: SEL.COLUMNS["Service Type"],
                                                    value: rowValues.servType,
                                                    fieldName: "Service Type"
                                                });
                                            }

            // –ó–∞–¥–µ—Ä–∂–∫–∞ –ø–µ—Ä–µ–¥ –æ–±—Ä–∞–±–æ—Ç–∫–æ–π —Å–ª–µ–¥—É—é—â–µ–π —Å—Ç—Ä–æ–∫–∏
            await this.wait(100); // ‚ùóÔ∏è –ù–µ —É–≤–µ–ª–∏—á–∏–≤–∞—Ç—å –∑–∞–¥–µ—Ä–∂–∫—É
        }

        // –ï—Å–ª–∏ –Ω–µ–æ–±—Ö–æ–¥–∏–º–æ —Å–Ω—è—Ç—å —Ñ–æ–∫—É—Å –ø–æ—Å–ª–µ –æ–±—Ä–∞–±–æ—Ç–∫–∏ –≤—Å–µ—Ö —Å—Ç—Ä–æ–∫, –º–æ–∂–Ω–æ —Ä–∞—Å–∫–æ–º–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å —Å–ª–µ–¥—É—é—â–∏–π –≤—ã–∑–æ–≤
        // await this.clickOnBlank();

        this.log('üéâ All rows processed successfully.');
    }

}

/**
 * –ú–µ—Ç–æ–¥ –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø–æ —Å–µ–ª–µ–∫—Ç–æ—Ä—É
 * @param {string} description - –û–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
 * @param {string} selector - –°–µ–ª–µ–∫—Ç–æ—Ä –¥–ª—è –ø–æ–∏—Å–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
 */
DateUpdater.prototype.logElements = function(description, selector) {
    const elements = document.querySelectorAll(selector);
    if (elements.length === 0) {
        console.warn(`‚ùå ${description}: –ù–µ—Ç –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø–æ —Å–µ–ª–µ–∫—Ç–æ—Ä—É "${selector}"`);
    } else {
        console.log(`‚úÖ ${description}: –ù–∞–π–¥–µ–Ω–æ ${elements.length} —ç–ª–µ–º–µ–Ω—Ç(–æ–≤) –ø–æ —Å–µ–ª–µ–∫—Ç–æ—Ä—É "${selector}"`);
        elements.forEach((el, index) => {
            console.log(`   [${index}] Tag: ${el.tagName}, ID: ${el.id || '–Ω–µ—Ç'}, Classes: ${el.className}`);
        });
    }
};




class TableProcessor {
    constructor(columns) {
        // Store the columns map for verification and extraction
        this.columns = columns;
        this.createdRowsCount = 0; // Track the number of rows created
    }

    verifyHeaders() {
        // Select all column headers from the table
        const headers = document.querySelectorAll('div.svmx-column-header-inner');
            const headerTexts = Array.from(headers).map(header => header.textContent.trim());

        // Check if all expected headers are present
                const missingHeaders = Object.keys(this.columns).filter(header => !headerTexts.includes(header));
                    if (missingHeaders.length > 0) {
                        alert(`Missing headers in table: ${missingHeaders.join(', ')}`);
                        throw new Error(`Missing headers in table: ${missingHeaders.join(', ')}`);
                    }

        // Verify if each header in the map matches its corresponding class in the table
                    for (const [header, className] of Object.entries(this.columns)) {
                        const headerIndex = headerTexts.indexOf(header);
                        if (headerIndex === -1) continue;

                        const columnClassExists = document.querySelector(`td.${className}`);
                        if (!columnClassExists) {
                            alert(`Class mismatch for header "${header}" (expected: ${className})`);
                            throw new Error(`Class mismatch for header "${header}" (expected: ${className})`);
                        }
                    }

                    console.log('All headers and column classes verified successfully.');
                }

                createRows() {    
                    console.log('Creating 3 rows...');

                        return new Promise((resolve, reject) => {
            // Find the Add Row button
                            const addRowButton = document.querySelector('#sfm-button-1099-btnEl');
                            if (!addRowButton) {
                                alert('Error: Add Row button not found');
                                return reject(new Error('Add Row button not found'));
                            }

            // Click the button 3 times to create rows
                            for (let i = 0; i < 3; i++) {
                                addRowButton.click();
                            }

            // Wait a short delay to allow rows to be added dynamically
                            setTimeout(() => {
                                const rows = document.querySelectorAll('tr.svmx-grid-row');
                                const newRowsCount = rows.length;

                                if (newRowsCount < 3) {
                                    alert(`Error: Failed to create 3 rows. Only ${newRowsCount} rows were created.`);
                                    return reject(new Error(`Failed to create 3 rows. Only ${newRowsCount} rows were created.`));
                                }

                this.createdRowsCount = 3; // Update the number of rows created
                console.log('3 rows created successfully.');
                resolve();
            }, 500); // Adjust the delay as needed
                        });
                    }

                    extractData() {
                        console.log('Extracting data from rows...');

        // Find all rows in the table
                            const rows = document.querySelectorAll('tr.svmx-grid-row');

        // Get only the last `this.createdRowsCount` rows, which were recently created
                                const newRows = Array.from(rows).slice(-this.createdRowsCount);

        // Prepare an object to store extracted data for each column
                                    const columnData = {};
                                    Object.keys(this.columns).forEach(header => {
            columnData[header] = []; // Initialize an empty array for each column
        });

        // Extract data from the selected rows
        newRows.forEach(row => {
            Object.keys(this.columns).forEach(header => {
                const className = this.columns[header]; // Get the class for the column
                const cell = row.querySelector(`td.${className}`); // Locate the cell by its class
                const cellContent = cell ? cell.textContent.trim() : 'No Data';
                columnData[header].push(cellContent); // Collect data for the column
            });
        });

        // Output the extracted data, grouped by columns
        Object.keys(columnData).forEach(header => {
            console.log(`${header}:`);
            columnData[header].forEach((value, index) => {
                console.log(`  Row ${index + 1}: ${value}`);
            });
        });
    }

    async run() {
        try {
            this.verifyHeaders(); // Verify headers and map them to classes
            await this.createRows(); // Create rows
            this.extractData(); // Extract and display data from the rows
        } catch (error) {
            console.error('‚ùå Error during TableProcessor.run():', error.message);
        }
    }

    /**
     * –ú–µ—Ç–æ–¥ –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø–æ —Å–µ–ª–µ–∫—Ç–æ—Ä—É
     * @param {string} description - –û–ø–∏—Å–∞–Ω–∏–µ –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
     * @param {string} selector - –°–µ–ª–µ–∫—Ç–æ—Ä –¥–ª—è –ø–æ–∏—Å–∫–∞ —ç–ª–µ–º–µ–Ω—Ç–æ–≤
     */
    logElements(description, selector) {
        const elements = document.querySelectorAll(selector);
            if (elements.length === 0) {
                console.warn(`‚ùå ${description}: –ù–µ—Ç –Ω–∞–π–¥–µ–Ω–Ω—ã—Ö —ç–ª–µ–º–µ–Ω—Ç–æ–≤ –ø–æ —Å–µ–ª–µ–∫—Ç–æ—Ä—É "${selector}"`);
            } else {
                console.log(`‚úÖ ${description}: –ù–∞–π–¥–µ–Ω–æ ${elements.length} —ç–ª–µ–º–µ–Ω—Ç(–æ–≤) –ø–æ —Å–µ–ª–µ–∫—Ç–æ—Ä—É "${selector}"`);
                elements.forEach((el, index) => {
                    console.log(`   [${index}] Tag: ${el.tagName}, ID: ${el.id || '–Ω–µ—Ç'}, Classes: ${el.className}`);
                });
            }
        }
    }


/**
 * –ö–ª–∞—Å—Å –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å—Ç—Ä–æ–∫ —Ç–∞–±–ª–∏—Ü—ã —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º TableProcessor –∏ DateUpdater
 */

// Instantiate TableProcessor with expected headers and classes
    const COLUMNS = {
        "Hour Type": "svmx-grid-cell-gridcolumn-1081",
        "Service Type": "svmx-grid-cell-gridcolumn-1082",
        "Start Date Time": "svmx-grid-cell-gridcolumn-1083",
        "End Date Time": "svmx-grid-cell-gridcolumn-1084"
    };
    const tableProcessor = new TableProcessor(COLUMNS);
//tableProcessor.run();

// Instantiate DateUpdater with debugging enabled
const dateUpdater = new DateUpdater(false); // –£—Å—Ç–∞–Ω–æ–≤–∏—Ç–µ false –¥–ª—è –≤–∫–ª—é—á–µ–Ω–∏—è –æ—Ç–ª–∞–¥–∫–∏

// Instantiate ProcessManager with TableProcessor and DateUpdater
const processManager = new ProcessManager(tableProcessor, dateUpdater);

// Run the process: verify headers, create rows, and fill the last three rows
processManager.createAndFillRows();
